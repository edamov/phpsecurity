# CSRF

CSRF (Cross-Site Request Forgery, также XSRF) - атака, которая приводит к тому, что злоумышленник может выполнять на сторонних сайтах действия от имени других залогиненных пользователей. 

Единственная уважительная причина не использовать защиту от данного вида атак — сайт не хранит никакие пользовательские данные, а вы не используете панель администратора для редактирования материалов.

### Пример:
Один из типичных сценариев CSRF атаки:

* Пользователь авторизируется на уязвимом сайте (bank.com) и в браузере сохраняются куки.
* Пользователь попадает на страницу злоумышленника (через приглашение в емейле или каким-то другим способом), на которой находится html форма:

```html
<form action="http://bank.com/send-money" method="POST">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="for" value="John">
  ...
  <input type="submit" name="submit" value="Click and win a prize!">
</form>
```

* Пользователь по незнанию сабмитит форму (либо форма сабмитится автоматически из JS), cайт bank.com проверяет куки, видит, что посетитель авторизован и обрабатывает форму, profit!


### Защита:

Защищать необходимо все запросы, изменяющие данные на сервере.
https://habrahabr.ru/post/235247/
https://learn.javascript.ru/csrf
https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

Типичный способ защиты сайтов – это «секретный ключ» (secret), специальное значение, которое генерируется случайным образом и сохраняется в сессии посетителя. Его знает только сервер, посетителю мы его даже не будем показывать.

Затем на основе ключа генерируется «токен» (token). Токен делается так, чтобы с одной стороны он был отличен от ключа, в частности, может быть много токенов для одного ключа, с другой – чтобы было легко проверить по токену, сгенерирован ли он на основе данного ключа или нет.

Для каждого токена нужно дополнительное случайное значение, которое называют «соль» salt.

Пример вычесления токена:
```php
$token = $salt . ":" + md5($salt + ":" + $secret)
```

Не зная secret, невозможно сгенерировать token, который сервер воспримет как правильный.
Далее, токен добавляется в качестве скрытого поля к каждой форме, генерируемой на сервере.

То есть, «честная» форма для отсылки сообщений, созданная на bank.com, будет выглядеть так:
```html
<form action="http://bank.com/send" method="POST">
  <input type="hidden" name="csrf" value="1234:5ad02792a3285252e524ccadeeda3401">
  <textarea name="message">
    ...
  </textarea>
</form>
```
При её отправке сервер проверит поле csrf, удостоверится в правильности токена, и лишь после этого отошлёт сообщение.

«Злая страница» при всём желании не сможет сгенерировать подобную форму, так как не владеет secret, и токен будет неверным.

Такой токен также называют «подписью» формы, которая удостоверяет, что форма сгенерирована именно на сервере.

Эта подпись говорит о том, что автор формы – сервер, но ничего не гарантирует относительно её содержания.

Есть ситуации, когда мы хотим быть уверены, что некоторые из полей формы посетитель не изменил самовольно. Тогда мы можем включить в MD5 для формулы токена эти поля, например:
```php
$token = $salt . ":" + md5($salt + ":" . $secret + ":" . $request['money'])
```

При отправке формы сервер проверит подпись, подставив в неё известный ему secret и присланное значение `$request['money']`. При несовпадении либо secret не тот (хакер), либо `$request['money']` изменено.

Также для критических операций (изменение пароля, восстановление электронной почты и т.д.) рекмендуется использовать повторную аутентификацию.
CAPTHA - так же один из способов защиты от CSRF, но менее дружелюбный для пользователья чем генерация токена.
